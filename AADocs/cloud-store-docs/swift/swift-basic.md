# 目录结构
```
1.swift 是什么？
2.swift 能做什么？
3.swift 不能做什么？
4.什么是结构化数据？
5.swift中Account是什么？
6.swift中Container是什么？
6.swift中Object是什么？
```
## Swift 是什么
```
OpenStackObject Storage(Swift) 是开源的，用于创建可以扩展的、冗余的、对象存储引擎。
使用标准化的服务器存储PB级别的可用数据。它不是文件系统，实时的数据存储系统。  
它是一个长期的处处系统，为了获得，调用，更新一些静态的永久性数据。比如说，适合存储一些类型的
数据： 虚拟机镜像，图片存储，邮件存储，文档的备份。
没有单点或者主控节点，具有更强的扩展，冗余和持久性。
```
## Swift 能做什么?
```
有点在于处处非结构化的数据，大小文件据说性能都很好。（目前没有测试数据， 
adrian otto 说测试过10 亿个 1byte 数据）
```

## Swift 不能做什么？
```
Objects must be <5GB ： swift 1.2 之后已经对 object 的大小不做限制
Not a Filesystem ：不是文件系统。 swift 使用 REST API ，而不是使用传统意义上的文件操作
    命令， open(), read(), write(), seek(), 和 close() 等。
No File Locking ：干脆不支持“文件锁”。其实在 swift 中，“锁”的概念是没有必要的。
No Directory Hierarchies ：没有文件目录结构。 swift 可以模拟目录结构，但没有必要
Not a Database ：不是数据库。 swift 使用 account-container-object 
    的概念存储 object ，可以列表出指定 container 中的 object ，不支持 server
    端的查询和处理操作。
```

# Swift 概念
## Account（用于简单的文件权限访问控制）
```
出于访问安全性考虑，使用Swift系统，每个用户必须有一个账号（Account）。
只有通过Swift验证的账号才能访问Swift系统中的数据。
提供账号验证的节点被称为Account Server。Swift中由Swauth提供账号
权限认证服务。用户通过账号验证后将获得一个验证字符串（authentication token.），
后续的每次数据访问操作都需要传递这个字符串。
```
## Container（组织和管理数据，类似文件或者文件夹、不可以嵌套）
```
Swift中的container可以类比Windows操作系统中的文件夹或者Unix类操作系统中的目录，
用于组织管理数据，所不同的是container不能嵌套。数据都以Object的形式存放在container中
```

## 三个进程服务
```
Storage节点上主要运行三类存储服务进程：Account Server、Container Server 
和 Object Server，分别负责Account、Container、Object数据的存储，
所以，在一些文献中又把存储节点称作ACO节点。
```
## Swift 特性
```
1、极高的数据持久性，上面已经提到了。
2、各个存储的节点完全对等，是对称的系统架构。
3、因为是对称的系统架构，扩容的时候只需简单的增加机器，扩展性很好。
4、不存在单节点故障，前面提到因为各个节点完全对等，没有所谓的“主从”结构。

存储在Swift里面的数据有好几个备份，而且各个节点之间是平等的关系，
没有“主节点”这个概念，因此任意一个节点出现故障时，
数据并不会丢失（注意，这里是任意一个节点出现故障）。而与它形成对比的是Hadoop的HDFS。

HDFS有一个元数据存储节点，保存在HDFS集群中的所有文件都会在元
数据存储节点上保留一份元数据，元数据记录了每个文件的一些必要的信息，
例如文件大小，属于哪个用户，更新的时间，存储在HDFS哪台数据服务器上等等，
感觉这个元数据的概念有点类似Linux中文件的inode信息。HDFS的缺点是一旦元
数据服务器挂掉，那么整个HDFS集群就玩完了。当然，这只是我对HDFS一点浅显的认识，
真正的部署的时候肯定还有很多保护措施，HDFS的健壮性是很好的。

回到Swift上，Swift的元数据存储是完全均匀随机分布的，
并且与对象文件存储一样，元数据也会存储多份。

无论是HDFS也好，Swift也好，必须面对的一个问题就是如何保持数据的一致性。
因为一个文件并不是只保存一份的，在Swift中默认要保存3个副本，
当更新的时候这3个文件要同时更新，当其中一个文件损坏时必须能迅速的
复制一份完整的文件来替换。

Swift有3个服务来解决这个问题：Auditor、Updater和Replicator。 
Auditor运行在每个Swift服务器的后台持续地扫描磁盘来检测数据的完整性。
如果发现数据损坏，Auditor就会将该文件移动到隔离区域，
然后由Replicator负责用一个完好的拷贝来替代该数据。
如果更新失败，该次更新在本地文件系统上会被加入队列，
然后Updaters会继续处理这些失败了的更新工作。


```
刚才提到过，Swift没有元数据服务器，也就是说，不会特意为每一个文件生成一个类似
inode的东西，并且保存在特定的一个服务器上，这一点与HDFS有很大的不同。
那么剩下最后一个问题：Client要存储一个文件，用什么策略决定存在哪台Storage Node上呢？
（为了更好的表示，我们可以看下图如下图所示，图1为Swift架构，图2为对象存储）
![image](http://www.aboutyun.com/data/attachment/forum/201403/11/182644ep9d87ztvcn999av.jpg)
![image01](http://www.aboutyun.com/data/attachment/forum/201403/11/184028aieiti88i7l6i0nw.jpg)

可以看出，在对象存储中，存储的不仅是数据，还有与丰富的数据相关的属性信息。
系统会给每一个对象分配一个唯一的ID。对象本身是平等的，所有的ID都属于
一个平坦的地址空间，而并非文件系统那样的树状逻辑结构。
这种存储结构带来的好处是可以实现数据的智能化管理，因为对象本身包含了
元数据信息，甚至更多的属性，我们可以根据这些信息对对象进行高效的管理。
例如我们可以制定这样的存储策略，如果对象中包含priority:high，
这样的属性，我们就对文件做比平常文件多的备份次数。
平坦地址空间的设计使得访问对象只通过一个唯一的ID标识即可，不需要复杂的路径结构。
因此，可以知道Swift中没有“路径”这个概念，所以也没有有所谓的“文件夹”这样的概念。
现在，我们有了对象的ID了，那么如何根据这个ID把对象存在合适的Storage Node呢？



